// Code generated by "go-enumerator"; DO NOT EDIT.

package example

import (
	"encoding"
	"fmt"
)

// String implements [fmt.Stringer]. If !k.Defined(), then a generated string is returned based on k's value.
func (k Kind) String() string {
	switch k {
	case Kind1:
		return "Kind1"
	case Kind2:
		return "Kind2"
	case KindX:
		return "Kind3"
	}
	return fmt.Sprintf("Kind(%d)", k)
}

// Bytes returns a byte-level representation of String(). If !k.Defined(), then a generated string is returned based on k's value.
func (k Kind) Bytes() []byte {
	switch k {
	case Kind1:
		return []byte{'K', 'i', 'n', 'd', '1'}
	case Kind2:
		return []byte{'K', 'i', 'n', 'd', '2'}
	case KindX:
		return []byte{'K', 'i', 'n', 'd', '3'}
	}
	return []byte(fmt.Sprintf("Kind(%d)", k))
}

// Defined returns true if k holds a defined value.
func (k Kind) Defined() bool {
	switch k {
	case 0, 1, 2:
		return true
	default:
		return false
	}
}

// Scan implements [fmt.Scanner]. Use [fmt.Scan] to parse strings into Kind values
func (k *Kind) Scan(scanState fmt.ScanState, verb rune) error {
	token, err := scanState.Token(true, nil)
	if err != nil {
		return err
	}

	switch string(token) {
	case "Kind1":
		*k = Kind1
	case "Kind2":
		*k = Kind2
	case "Kind3":
		*k = KindX
	default:
		return fmt.Errorf("unknown Kind value: %s", token)
	}
	return nil
}

// Next returns the next defined Kind. If k is not defined, then Next returns the first defined value.
// Next() can be used to loop through all values of an enum.
//
//	k := Kind(0)
//	for {
//		fmt.Println(k)
//		k = k.Next()
//		if k == Kind(0) {
//			break
//		}
//	}
//
// The exact order that values are returned when looping should not be relied upon.
func (k Kind) Next() Kind {
	switch k {
	case Kind1:
		return Kind2
	case Kind2:
		return KindX
	case KindX:
		return Kind1
	default:
		return Kind1
	}
}

func _() {
	var x [1]struct{}
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the go-enumerator command to generate them again.
	_ = x[Kind1-0]
	_ = x[Kind2-1]
	_ = x[KindX-2]
}

// MarshalText implements [encoding.TextMarshaler]
func (k Kind) MarshalText() ([]byte, error) {
	return k.Bytes(), nil
}

// UnmarshalText implements [encoding.TextUnmarshaler]
func (k *Kind) UnmarshalText(x []byte) error {
	switch string(x) {
	case "Kind1":
		*k = Kind1
		return nil
	case "Kind2":
		*k = Kind2
		return nil
	case "Kind3":
		*k = KindX
		return nil
	default:
		return fmt.Errorf("failed to parse value %v into %T", x, *k)
	}
}

var (
	_ fmt.Stringer             = Kind(0)
	_ fmt.Scanner              = new(Kind)
	_ encoding.TextMarshaler   = Kind(0)
	_ encoding.TextUnmarshaler = new(Kind)
)
